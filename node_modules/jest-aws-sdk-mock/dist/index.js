"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var aws_sdk_1 = __importDefault(require("aws-sdk"));
var lodash_get_1 = __importDefault(require("lodash.get"));
var stream_1 = require("stream");
var AWSInstance = aws_sdk_1.default;
var serviceMap = {};
function setSDK(path) {
    AWSInstance = require(path);
}
exports.setSDK = setSDK;
function setSDKInstance(sdk) {
    AWSInstance = sdk;
}
exports.setSDKInstance = setSDKInstance;
function mock(service, method, impl) {
    if (!serviceMap[service]) {
        mockService(service);
    }
    mockServiceMethod(service, method, impl);
    return serviceMap[service].methods[method];
}
exports.mock = mock;
function mockService(service) {
    var serviceParts = service.split('.');
    var originalConstructor = getService(service);
    var parent = serviceParts.length > 1
        ? lodash_get_1.default(AWSInstance, serviceParts.slice(0, serviceParts.length - 1))
        : AWSInstance;
    var lastServicePart = serviceParts[serviceParts.length - 1];
    var mockConstructor = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (serviceMap[service].client) {
            return serviceMap[service].client;
        }
        serviceMap[service].client = new (originalConstructor.bind.apply(originalConstructor, __spreadArrays([void 0], args)))();
        for (var _a = 0, _b = Object.keys(serviceMap[service].methods); _a < _b.length; _a++) {
            var method = _b[_a];
            updateAWSServiceMethod(service, method);
        }
        return serviceMap[service].client;
    };
    var mock = jest
        .spyOn(parent, lastServicePart)
        .mockImplementation(mockConstructor);
    for (var _i = 0, _a = Object.keys(originalConstructor || {}); _i < _a.length; _i++) {
        var key = _a[_i];
        var property = originalConstructor[key];
        mock[key] =
            typeof property === 'function'
                ? property.bind(originalConstructor)
                : property;
    }
    try {
        jest.doMock("aws-sdk/clients/" + service.toLowerCase(), function () {
            return mock;
        });
    }
    catch (e) {
        // module does not exist
    }
    serviceMap[service] = {
        methods: {},
        invoked: false,
        mock: mock,
    };
}
function getService(service) {
    var serviceParts = service.split('.');
    return lodash_get_1.default(AWSInstance, serviceParts);
}
function mockServiceMethod(service, method, impl) {
    serviceMap[service].methods[method] = {
        mock: jest.fn().mockImplementation(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var client = serviceMap[service].client;
            var userArgs, userCallback;
            if (typeof args[(args.length || 1) - 1] === 'function') {
                userArgs = args.slice(0, -1);
                userCallback = args[(args.length || 1) - 1];
            }
            else {
                userArgs = args;
            }
            var promise, chains = [], storedResult, callbackCalled = false;
            function tryResolveFromStored() {
                if (storedResult) {
                    if (typeof storedResult.then === 'function') {
                        for (var _i = 0, chains_1 = chains; _i < chains_1.length; _i++) {
                            var chain = chains_1[_i];
                            storedResult.then(chain.resolve, chain.reject);
                        }
                    }
                    else if (storedResult.reject) {
                        for (var _a = 0, chains_2 = chains; _a < chains_2.length; _a++) {
                            var chain = chains_2[_a];
                            chain.reject(storedResult.reject);
                        }
                    }
                    else {
                        for (var _b = 0, chains_3 = chains; _b < chains_3.length; _b++) {
                            var chain = chains_3[_b];
                            chain.resolve(storedResult.resolve);
                        }
                    }
                    chains = [];
                }
            }
            var callback = function (err, data) {
                if (data === void 0) { data = null; }
                callbackCalled = true;
                if (err) {
                    storedResult = { reject: err };
                }
                else {
                    storedResult = { resolve: data };
                }
                if (userCallback) {
                    userCallback(err, data);
                }
                tryResolveFromStored();
            };
            var request = {
                promise: function () {
                    var PromiseClass = AWSInstance.config.getPromisesDependency() || Promise;
                    promise = new PromiseClass(function (resolve, reject) {
                        chains.push({
                            resolve: resolve,
                            reject: reject,
                        });
                    });
                    tryResolveFromStored();
                    return promise;
                },
                createReadStream: function () {
                    if (impl instanceof stream_1.Readable) {
                        return impl;
                    }
                    else {
                        var stream = new stream_1.Readable();
                        stream._read = function () {
                            if (typeof impl === 'string' ||
                                Buffer.isBuffer(impl)) {
                                this.push(impl);
                            }
                            this.push(null);
                        };
                        return stream;
                    }
                },
                on: none,
                send: none,
            };
            var config = client.config || client.options || AWSInstance.config;
            if (config.paramValidation) {
                try {
                    var inputRules = ((client.api && client.api.operations[method]) ||
                        client[method] ||
                        {}).input;
                    if (inputRules) {
                        var params = userArgs[(userArgs.length || 1) - 1];
                        new AWSInstance.ParamValidator((client.config || AWSInstance.config).paramValidation).validate(inputRules, params);
                    }
                }
                catch (e) {
                    callback(e, null);
                    return request;
                }
            }
            if (typeof impl === 'function') {
                var result = impl.apply(void 0, __spreadArrays(userArgs, [callback]));
                if (result != null && typeof result.then === 'function') {
                    storedResult = result;
                    if (!callbackCalled) {
                        storedResult.then(function (data) { return callback(null, data); }, function (err) { return callback(err); });
                    }
                }
            }
            else {
                callback(null, impl);
            }
            return request;
        }),
    };
    updateAWSServiceMethod(service, method);
}
function updateAWSServiceMethod(service, method) {
    var _a, _b, _c;
    if (!((_a = serviceMap[service]) === null || _a === void 0 ? void 0 : _a.client) ||
        !((_c = (_b = serviceMap[service]) === null || _b === void 0 ? void 0 : _b.methods[method]) === null || _c === void 0 ? void 0 : _c.mock)) {
        return;
    }
    var methodImpl = serviceMap[service].methods[method].mock;
    var originalClient = serviceMap[service].client;
    if (!serviceMap[service].methods[method].original) {
        serviceMap[service].methods[method].original = originalClient[method].bind(originalClient);
    }
    originalClient[method] = methodImpl;
}
function restore(service, method) {
    if (service === void 0) { service = ''; }
    if (method === void 0) { method = ''; }
    if (!service) {
        restoreAllServices();
    }
    else {
        if (method) {
            restoreMethod(service, method);
        }
        else {
            restoreService(service);
        }
    }
}
exports.restore = restore;
/**
 * Restores all mocked service and their corresponding methods.
 */
function restoreAllServices() {
    for (var _i = 0, _a = Object.keys(serviceMap); _i < _a.length; _i++) {
        var service = _a[_i];
        restoreService(service);
    }
}
/**
 * Restores a single mocked service and its corresponding methods.
 */
function restoreService(service) {
    var _a;
    if (serviceMap[service]) {
        restoreAllMethods(service);
        if (serviceMap[service].mock) {
            (_a = serviceMap[service].mock) === null || _a === void 0 ? void 0 : _a.mockRestore();
        }
        delete serviceMap[service];
        try {
            jest.dontMock("aws-sdk/clients/" + service.toLowerCase());
        }
        catch (e) {
            // module does not exist
        }
    }
}
/**
 * Restores all mocked methods on a service.
 */
function restoreAllMethods(service) {
    for (var _i = 0, _a = Object.keys(serviceMap[service].methods); _i < _a.length; _i++) {
        var method = _a[_i];
        restoreMethod(service, method);
    }
}
/**
 * Restores a single mocked method on a service.
 */
function restoreMethod(service, method) {
    var _a;
    if ((_a = serviceMap[service]) === null || _a === void 0 ? void 0 : _a.methods[method]) {
        if (serviceMap[service].methods[method].original &&
            serviceMap[service].client) {
            serviceMap[service].client[method] =
                serviceMap[service].methods[method].original;
        }
        delete serviceMap[service].methods[method];
    }
}
function none() {
    // do nothing
}
//# sourceMappingURL=index.js.map